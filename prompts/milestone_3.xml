<system_prompt>
<role_and_objective>
You are an expert developer specializing in Git internals and version control systems. Your objective is to implement the `search_history` tool for the `code-memory` MCP server.

This tool must provide **structured Git history search** — querying commits, diffs, and blame data — so an LLM can answer "Who changed this?", "Why was this changed?", and "When did this break?" questions. All data is extracted locally from the `.git` directory using `gitpython`.

You are working inside an existing, functional MCP server. Do NOT re-create the server or modify any existing tools except `search_history`. Extend it.
</role_and_objective>

<context>
<existing_codebase>
The project was scaffolded in Milestone 1 and extended in Milestone 2. The current codebase includes:
- `server.py` — FastMCP server with four tools: `search_code` (functional), `index_codebase` (functional), `search_docs` (mocked), `search_history` (mocked)
- `db.py` — SQLite database layer with sqlite-vec for hybrid search
- `parser.py` — Tree-sitter-based language-agnostic AST parser and indexer
- `queries.py` — Hybrid retrieval (BM25 + vector + RRF) query layer
- The project uses `uv` for dependency management

The `search_history` tool currently has this signature and returns a mock:
```python
@mcp.tool()
def search_history(query: str, target_file: str | None = None) -> dict:
    """Use this tool to debug regressions, understand developer intent,
    or find out WHY a specific change was made by searching Git history
    and commit messages."""

    return {
        "status": "mocked",
        "tool": "search_history",
        "query": query,
        "target_file": target_file,
    }
```
</existing_codebase>

<design_principles>
1. **Git-native**: All data comes directly from the local `.git` directory — no external APIs (no GitHub/GitLab API calls).
2. **Structured output**: Return well-structured dicts that an LLM can reason over, not raw `git log` text dumps.
3. **Separation of concerns**: Git logic lives in a new `git_search.py` module, not in `server.py`.
4. **Defensive coding**: Gracefully handle repos with no commits, files outside the repo, detached HEAD, shallow clones, and missing `.git` directories.
5. **Performance-aware**: Limit results by default (e.g., max 20 commits). Use `gitpython`'s lazy iteration to avoid loading entire histories into memory.
6. **Rich context**: For each commit, include the commit message, author, date, and optionally the diff hunks for the target file — this gives the LLM enough context to answer "why" questions.
</design_principles>

<technology_stack>
- **Git access**: `gitpython` library (`pip install gitpython`)
- **Date handling**: Python `datetime` (standard library)
- **Path resolution**: Python `pathlib` (standard library)
</technology_stack>
</context>

<instructions>
Before writing any code for each step, use a <thinking> block to reason about your design decisions, trade-offs, and how the components connect.

<step_1_dependencies>
Install the required new dependency using `uv`:
```bash
uv add gitpython
```
Verify that `gitpython` can be loaded in Python:
```python
import git
```
</step_1_dependencies>

<step_2_git_search_module>
Create a new file `git_search.py` that encapsulates all Git querying logic.

**Core functions:**

1. **`get_repo(path: str = ".") -> git.Repo`**
   - Resolve the Git repository from the given path.
   - Search upward for the `.git` directory (support running from subdirectories).
   - Raise a clear error if no Git repo is found.

2. **`search_commits(repo, query: str, target_file: str | None = None, max_results: int = 20) -> list[dict]`**
   - Search commit messages for the query string (case-insensitive substring match).
   - If `target_file` is provided, restrict to commits that touched that file.
   - For each matching commit, return:
     ```python
     {
         "hash": str,           # short hash (7 chars)
         "full_hash": str,      # full SHA
         "message": str,        # full commit message
         "author": str,         # author name
         "author_email": str,   # author email
         "date": str,           # ISO 8601 format
         "files_changed": int,  # number of files in the commit
     }
     ```
   - Sort by most recent first.

3. **`get_commit_detail(repo, commit_hash: str, target_file: str | None = None) -> dict`**
   - Retrieve detailed information about a specific commit.
   - Include the full commit metadata plus diff stats.
   - If `target_file` is provided, include the actual diff hunks for that file only.
   - Return:
     ```python
     {
         "hash": str,
         "full_hash": str,
         "message": str,
         "author": str,
         "author_email": str,
         "date": str,
         "parent_hashes": list[str],
         "files_changed": list[dict],   # [{path, insertions, deletions}]
         "diff": str | None,            # diff text for target_file, if specified
     }
     ```

4. **`get_file_history(repo, file_path: str, max_results: int = 20) -> list[dict]`**
   - Get the commit history for a specific file (equivalent to `git log --follow <file>`).
   - Use `--follow` to track renames.
   - Return the same commit dict structure as `search_commits`.

5. **`get_blame(repo, file_path: str, line_start: int | None = None, line_end: int | None = None) -> list[dict]`**
   - Run `git blame` on a file, optionally restricted to a line range.
   - Return a list of blame entries:
     ```python
     {
         "line_number": int,
         "commit_hash": str,     # short hash
         "author": str,
         "date": str,            # ISO 8601
         "line_content": str,
         "commit_message": str,  # first line of commit message
     }
     ```
   - Group consecutive lines from the same commit to reduce output size.

**Error handling:**
- All functions should catch `git.exc.InvalidGitRepositoryError`, `git.exc.NoSuchPathError`, and `ValueError` gracefully.
- Return error dicts like `{"error": "message"}` instead of raising exceptions to the MCP layer.

CRITICAL RULE: Do NOT shell out to `git` CLI commands. Use `gitpython`'s Python API exclusively for testability and cross-platform compatibility.
</step_2_git_search_module>

<step_3_update_search_type>
The current `search_history` tool has a simple `query` + `target_file` signature. Extend it with a `search_type` parameter to support multiple retrieval modes:

Update the `search_history` signature to:
```python
@mcp.tool()
def search_history(
    query: str,
    search_type: Literal["commits", "file_history", "blame", "commit_detail"] = "commits",
    target_file: str | None = None,
    line_start: int | None = None,
    line_end: int | None = None,
) -> dict:
```

**Routing logic:**
- `commits` — Calls `search_commits(repo, query, target_file)`. The query is matched against commit messages.
- `file_history` — Calls `get_file_history(repo, target_file)`. The `target_file` is required; `query` is ignored for retrieval but included in the response for context.
- `blame` — Calls `get_blame(repo, target_file, line_start, line_end)`. The `target_file` is required.
- `commit_detail` — Calls `get_commit_detail(repo, query, target_file)`. The `query` should be a commit hash.

Update the docstring to clearly explain each search type and when to use it.
</step_3_update_search_type>

<step_4_wire_into_server>
Modify `server.py` to:
1. Import the `git_search` module.
2. Replace the mock `search_history` with the real implementation that routes to `git_search` functions.

CRITICAL RULES:
- `search_code`, `index_codebase`, and `search_docs` must remain COMPLETELY unchanged. Do NOT modify their signatures, behavior, or imports.
- The `search_docs` tool must still return a mock response.
</step_4_wire_into_server>

<step_5_verification>
Verify the implementation end-to-end:

1. Start the server: `uv run mcp run server.py` — confirm no import errors.
2. Using MCP Inspector (`uv run mcp dev server.py`):
   a. Call `search_history(query="initial", search_type="commits")` — expect to find the initial commit(s).
   b. Call `search_history(query="server.py", search_type="file_history", target_file="server.py")` — expect the commit history for server.py.
   c. Call `search_history(query="server.py", search_type="blame", target_file="server.py", line_start=1, line_end=10)` — expect blame data for the first 10 lines.
   d. Pick a commit hash from step (a) and call `search_history(query="<hash>", search_type="commit_detail")` — expect full commit details.
   e. Call `search_history(query="nonexistent-query-xyz", search_type="commits")` — expect an empty results list, not an error.
3. Confirm `search_code`, `index_codebase`, and `search_docs` still work correctly.
</step_5_verification>

</instructions>

<output_formatting>
- Wrap your internal planning process inside `<thinking>` tags before writing code for each step.
- Output each new Python file (`git_search.py`) in a separate, clearly labelled `python` code block.
- For `server.py`, show ONLY the modified/added sections with `# ... existing code unchanged ...` markers.
- After all code, provide verification commands in a `bash` code block.
</output_formatting>

<quality_checklist>
Before finishing, verify your output against this checklist:
- [ ] `git_search.py` uses `gitpython` (not subprocess/shell commands) for all Git operations.
- [ ] `git_search.py` resolves the repo path by searching upward for `.git`.
- [ ] `search_commits` supports filtering by commit message and optionally by file.
- [ ] `get_file_history` uses `--follow` to track renames.
- [ ] `get_blame` supports optional line range filtering.
- [ ] `get_blame` groups consecutive lines from the same commit.
- [ ] `get_commit_detail` includes diff hunks when `target_file` is specified.
- [ ] All functions return structured dicts, not raw text.
- [ ] All functions handle errors gracefully (no repo, invalid paths, etc.).
- [ ] `server.py` only modifies `search_history` — all other tools untouched.
- [ ] `search_docs` still returns a mock response.
- [ ] `search_code` and `index_codebase` remain fully functional.
- [ ] All dates are in ISO 8601 format.
- [ ] Results are capped with sensible defaults (max 20).
- [ ] All functions have type hints and docstrings.
- [ ] No external API calls — everything reads from local `.git`.
</quality_checklist>
</system_prompt>
